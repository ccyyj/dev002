# 前情提要

永强的公司老板突然在发工资的前一天带着小姨子跑路了，可怜的永强一身房贷，被迫提起劳动仲裁，劳动局就会为其指派一位代理律师全权负责永强的仲裁事宜。那这里面就是使用了代理模式，因为在劳动仲裁这个活动中，代理律师会全权代理永强。

## 静态代理

Interface

```java
// 诉讼接口
public interface LawSuit {
    // 提起诉讼
    void submit();

    // 法庭辩护
    void defend();
}
```

Service

```java
// 诉讼当事人(原告)
public class Parties implements LawSuit {
    @Override
    public void submit() {
        System.out.println("老板欠薪跑路，证据确凿！！！");
    }

    @Override
    public void defend() {
        System.out.println("铁证如山，欠债还钱");
    }
}
```

Proxy

```java
// 代理律师类，全权负责案件的代理
public class Lawyer implements LawSuit {
    // 包含一个被代理的对象
    private final LawSuit lawSuit;

    // 通过构造方法传递被代理对象
    public Lawyer(LawSuit lawSuit) {
        this.lawSuit = lawSuit;
    }

    @Override
    public void submit() {
        // 搜集证据
        this.gatherEvidence();

        // 提起诉讼
        this.lawSuit.submit();
    }

    @Override
    public void defend() {
        // 法庭辩护
        this.lawSuit.defend();

        // 交换意见
        this.compareNotes();
    }

    // 搜集证据(属于增强的方法)
    private void gatherEvidence() {
        System.out.println("搜集证据");
    }

    // 交换意见(属于增强的方法)
    private void compareNotes() {
        System.out.println("与审判长、审判员交换意见，被告如果不服，代其上诉或申诉");
    }
}
```

Client

```java
// 开庭
public class Court {
    @Test
    public void testLawSuit() {
        // 当事人安排上
        Parties parties = new Parties();

        // 当事人的代理律师安排上
        Lawyer lawyer = new Lawyer(parties);

        // 代理律师进行提起诉讼以及法庭辩护
        lawyer.submit();
        lawyer.defend();
    }
}
```



## 动态代理JDK核心API

```java
// 由代理对象的调用处理程序实现的接口，在代理对象上调用方法时，该方法调用将被编码并分派到其调用处理程序的invoke方法。
interface InvocationHandler {
    // 处理代理对象上的方法调用并返回结果
    // 参数：
    //      proxy ——> 代理对象
    //		method --> 被代理类要执行的方法
    //		args --> 被代理类要执行的方法的参数
    // 返回值：被代理类要执行的方法的返回值
    public Object invoke(Object proxy, Method method, Object[] args);
}

// 提供了用于创建动态代理类和实例的静态方法
class Proxy {
    // 返回指定接口的代理类对象，该对象将方法调用分派到指定的调用处理程序
    // 参数：
    //      loader ——> 被代理类的类加载器
    //		interfaces --> 被代理类要实现的所有接口
    //		h --> 将方法调用分派给指定的执行处理器
    // 返回值：代理对象
    static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);
}
```



Interface

```java
// 诉讼接口
public interface LawSuit {
    // 提起诉讼
    void submit();

    // 法庭辩护
    void defend();
}
```

Service

```java
// 诉讼当事人(原告)
public class Parties implements LawSuit {
    @Override
    public void submit() {
        System.out.println("老板欠薪跑路，证据确凿！！！");
    }

    @Override
    public void defend() {
        System.out.println("铁证如山，欠债还钱");
    }
}
```

InvocationHandler

```java
// 律师事务所，实现JDK动态代理的核心接口InvocationHandler
public class LawOffice implements InvocationHandler {
    // 包含一个动态的被代理对象(当事人)
    private final Object target;

    // 通过构造方法进行传参
    public LawOffice(Object obj) {
        this.target = obj;
    }

    /**
     * 此方法用于代理对象调用被代理对象的操作
     *
     * @param proxy 代理对象(律师)
     * @param method 被代理对象的方法
     * @param args 被代理对象的方法所需要的参数
     * @return 被代理对象的方法执行后的返回值
     * @throws Throwable 非法参数异常、安全异常、空指针异常
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 获取被代理对象方法的方法名
        System.out.println("案情进展：" + method.getName());

        // 执行被代理对象的方法
        return method.invoke(target, args);
    }
}
```

Client

```java
// 开庭
public class Court {
    @Test
    public void testLawSuit() {
        // 安排一个当事人(被代理对象)
        Parties parties = new Parties();

        // 安排一个律师(代理对象)
        InvocationHandler handler = new LawOffice(parties);

        // 根据被代理对象的类加载器、类的所有对象以及InvocationHandler接口实现类来获取代理对象(代理律师)
        LawSuit lawSuit = (LawSuit) Proxy.newProxyInstance(parties.getClass().getClassLoader(), parties.getClass().getInterfaces(), handler);

        // 代理对象执行方法
        lawSuit.submit();
        lawSuit.defend();
    }
}
```



## 动态代理CGLib核心API

```java
// 方法增强回调器，用来拦截代理对象的方法并对其增强
interface MethodInterceptor extends Callback {
    
    // 所有的代理对象都将执行此方法而不是原始方法
    // 参数：
    // 		obj --> 被代理对象
    // 		method --> 被代理对象的方法
    // 		args --> 被代理对象的方法参数
    //		proxy --> 代理对象
    // 返回值：被代理对象的方法返回值
    Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable;
}

// 代理类
class MethodProxy {
    // 调用相同类型且不同对象的原始方法，此方法可能会导致递归，进而引发栈内存溢出，慎用
    Object invoke(Object obj, Object[] args)
    
    // 调用指定对象的原始方法
    Object invokeSuper(Object obj, Object[] args);
}

// 生成动态代理对象以启用方法拦截，该类允许代理除了实现接口外，扩展一个具体的基类
class Enhancer {
    // 设置被代理类
    // 参数：
    // 		superclass --> 被代理类，必须具有可访问的构造方法
    void setSuperclass(Class superclass);
    
    // 设置被代理接口
    void setInterfaces(Class[] interfaces);
    
    // 设置回调函数
    // 参数：
    // 		callback：传入MethodInterceptor的接口实现类
    void setCallback(final Callback callback);
    
    // 根据无参构造创建一个代理对象
    Object create();
    
    // 根据有参构造创建一个代理对象
    Object create(Class[] argumentTypes, Object[] arguments);
}
```

Service

```java
// 被代理对象
public class Parties {
    // 提起诉讼
    public void submit() {
        System.out.println("老板欠薪跑路，证据确凿！！！");
    }

    // 法庭辩护
    public void defend() {
        System.out.println("铁证如山，欠债还钱");
    }
}
```

MethodInterceptor

```java
// 律师事务所，实现CGLib动态代理的核心接口MethodInterceptor
public class LawOffice implements MethodInterceptor {
    /**
     * 所有生成的代理方法都调用此方法，而不是原始方法
     *
     * @param o 被代理对象
     * @param method 被代理对象的方法
     * @param objects 被代理对象的方法参数
     * @param methodProxy 代理对象，用来调用未被拦截的方法，可多次调用
     * @return 被代理对象的方法返回值
     * @throws Throwable
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("案件进度：" + method.getName());

        // 执行被代理对象中的方法
        Object result = methodProxy.invokeSuper(o, objects);
        return result;
    }
}
```

Client

```java
// 开庭
public class Court {
    @Test
    public void test() {
        // 安排一个当事人
        Parties parties = new Parties();

        // cgLib动态代理核心类，用于生成代理对象
        Enhancer enhancer = new Enhancer();

        // 指定被代理对象
        enhancer.setSuperclass(parties.getClass());
        // 设置回调拦截
        enhancer.setCallback(new LawOffice());
        // 创建代理对象
        Parties lawyer = (Parties) enhancer.create();

        // 执行方法
        lawyer.submit();
        lawyer.defend();
    }
}
```

